# 実装パターン

コードサンプル集。各コンポーネントの実装パターンを示す。

---

## Domain Model

### Entity（エンティティ）

ID で識別されるオブジェクト。状態遷移やビジネスルールを持つ。

```php
final class Order
{
    public function __construct(
        private OrderId $id,
        private CustomerId $customerId,
        private OrderStatus $status,
        private Money $amount,
    ) {}

    public function place(): void
    {
        if (!$this->status->canPlace()) {
            throw new DomainException('確定できない状態です');
        }

        $this->status = OrderStatus::placed();
    }

    public function cancel(): void
    {
        if (!$this->status->canCancel()) {
            throw new DomainException('キャンセルできない状態です');
        }

        $this->status = OrderStatus::cancelled();
    }

    public function id(): OrderId { return $this->id; }
    public function customerId(): CustomerId { return $this->customerId; }
    public function status(): OrderStatus { return $this->status; }
    public function amount(): Money { return $this->amount; }
}
```

**ポイント:**
- `final class` で継承を禁止
- 状態遷移メソッド（`place()`, `cancel()`）にビジネスルールを実装
- DB / Laravel に依存しない

---

### ValueObject（値オブジェクト）

値で識別される不変オブジェクト。

```php
final class Money
{
    public function __construct(
        private int $amount,
        private string $currency = 'JPY',
    ) {
        if ($amount < 0) {
            throw new InvalidArgumentException('金額は0以上');
        }
    }

    public function add(Money $other): self
    {
        if ($this->currency !== $other->currency) {
            throw new DomainException('通貨が異なります');
        }
        return new self($this->amount + $other->amount, $this->currency);
    }

    public function multiply(int $multiplier): self
    {
        return new self($this->amount * $multiplier, $this->currency);
    }

    public function isHighValue(): bool
    {
        return $this->amount >= 10000;
    }

    public static function fromInt(int $amount): self
    {
        return new self($amount);
    }

    public static function zero(): self
    {
        return new self(0);
    }

    public function toInt(): int
    {
        return $this->amount;
    }

    public function equals(Money $other): bool
    {
        return $this->amount === $other->amount
            && $this->currency === $other->currency;
    }
}
```

**ポイント:**
- 不変（immutable）: 変更メソッドは新しいインスタンスを返す
- 自己検証: コンストラクタでバリデーション
- 等価性: `equals()` メソッドで比較

---

### ValueObject（ID）

```php
final class OrderId
{
    public function __construct(
        private int $value,
    ) {
        if ($value <= 0) {
            throw new InvalidArgumentException('ID は正の整数');
        }
    }

    public static function from(int $value): self
    {
        return new self($value);
    }

    public function value(): int
    {
        return $this->value;
    }

    public function equals(OrderId $other): bool
    {
        return $this->value === $other->value;
    }
}
```

---

### ValueObject（ステータス）

```php
final class OrderStatus
{
    private const DRAFT = 'draft';
    private const PLACED = 'placed';
    private const CONFIRMED = 'confirmed';
    private const CANCELLED = 'cancelled';

    private function __construct(
        private string $value,
    ) {}

    public static function draft(): self
    {
        return new self(self::DRAFT);
    }

    public static function placed(): self
    {
        return new self(self::PLACED);
    }

    public static function confirmed(): self
    {
        return new self(self::CONFIRMED);
    }

    public static function cancelled(): self
    {
        return new self(self::CANCELLED);
    }

    public static function from(string $value): self
    {
        return match ($value) {
            self::DRAFT => self::draft(),
            self::PLACED => self::placed(),
            self::CONFIRMED => self::confirmed(),
            self::CANCELLED => self::cancelled(),
            default => throw new InvalidArgumentException("無効なステータス: {$value}"),
        };
    }

    public function canPlace(): bool
    {
        return $this->value === self::DRAFT;
    }

    public function canCancel(): bool
    {
        return in_array($this->value, [self::DRAFT, self::PLACED], true);
    }

    public function isPlaced(): bool
    {
        return $this->value === self::PLACED;
    }

    public function isConfirmed(): bool
    {
        return $this->value === self::CONFIRMED;
    }

    public function value(): string
    {
        return $this->value;
    }
}
```

**ポイント:**
- ファクトリメソッドで生成（`draft()`, `placed()` など）
- 状態遷移の可否を判定するメソッド（`canPlace()`, `canCancel()`）

---

### Enum（列挙型）と ValueObject の使い分け

PHP 8.1 以降ではネイティブの `enum` が利用可能。用途に応じて使い分ける。

#### Enum が適切なケース

**単純な区分値**（振る舞いを持たない列挙）

```php
enum BookFormat: string
{
    case Paperback = 'paperback';
    case Hardcover = 'hardcover';
    case Ebook = 'ebook';

    /**
     * 表示用ラベルを取得
     */
    public function label(): string
    {
        return match ($this) {
            self::Paperback => '文庫本',
            self::Hardcover => 'ハードカバー',
            self::Ebook => '電子書籍',
        };
    }
}

// 使用例
$format = BookFormat::Paperback;
$format->value;  // 'paperback'（DB保存用）
$format->label(); // '文庫本'（表示用）

// DB から復元
$format = BookFormat::from('paperback');
$format = BookFormat::tryFrom('invalid'); // null（例外を投げない）
```

**Enum のメリット:**
- 型安全性が高い（IDE 補完が効く）
- `->value` で簡単に永続化できる
- `from()` / `tryFrom()` で復元が容易
- 網羅性チェック（match 式で全ケースを強制）

#### ValueObject クラスが適切なケース

**ビジネスルールや状態遷移を持つもの**

```php
// ❌ enum では複雑になる例
enum OrderStatus: string
{
    case Draft = 'draft';
    case Placed = 'placed';
    case Confirmed = 'confirmed';
    case Cancelled = 'cancelled';

    // メソッドは追加できるが、ロジックが複雑になると管理しづらい
    public function canPlace(): bool
    {
        return $this === self::Draft;
    }

    public function canCancel(): bool
    {
        return in_array($this, [self::Draft, self::Placed], true);
    }
}

// ✅ ValueObject クラスの方が適切
final class OrderStatus
{
    // ... 前述の実装
}
```

**ValueObject クラスのメリット:**
- 複雑なビジネスルールを整理しやすい
- 状態遷移ロジックのテストが書きやすい
- 将来の拡張に対応しやすい

#### 判断基準

| 条件 | 推奨 |
|------|------|
| 単純な選択肢（カテゴリ、フォーマット等） | `enum` |
| 表示ラベルのみ必要 | `enum` |
| 状態遷移の可否判定が必要 | ValueObject クラス |
| 複数のビジネスルールを持つ | ValueObject クラス |
| 他の値オブジェクトと組み合わせる | ValueObject クラス |

#### Eloquent Model での Enum キャスト

```php
class BookRecord extends Model
{
    /**
     * キャスト定義
     *
     * @var array<string, string>
     */
    protected $casts = [
        'format' => BookFormat::class,
    ];
}

// 自動的に enum として取得・保存される
$book = BookRecord::find(1);
$book->format; // BookFormat::Paperback（enum インスタンス）

$book->format = BookFormat::Ebook;
$book->save(); // 'ebook' として保存される
```

---

## Eloquent Model

DB テーブルのマッピングに専念。ビジネスロジックは持たない。

```php
class OrderRecord extends Model
{
    protected $table = 'orders';

    protected $fillable = [
        'customer_id',
        'status',
        'amount',
    ];

    public function lines(): HasMany
    {
        return $this->hasMany(OrderLineRecord::class, 'order_id');
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(CustomerRecord::class, 'customer_id');
    }
}
```

**ポイント:**
- 命名は `{Name}Record` でDomain Modelと区別
- リレーション定義のみ
- ビジネスロジックは書かない

---

## Repository

### Interface（Domain 層）

```php
interface OrderRepository
{
    public function find(OrderId $id): Order;

    /** @return list<Order> */
    public function findByCustomer(CustomerId $id): array;

    public function save(Order $order): void;
}
```

**ポイント:**
- Domain 層に配置
- 戻り値は Domain Model（Eloquent ではない）
- `list<Order>` で配列を返す（Collection ではない）

---

### Implementation（Infrastructure 層）

```php
class EloquentOrderRepository implements OrderRepository
{
    public function find(OrderId $id): Order
    {
        $record = OrderRecord::findOrFail($id->value());

        return $this->toDomain($record);
    }

    public function findByCustomer(CustomerId $id): array
    {
        return OrderRecord::query()
            ->where('customer_id', $id->value())
            ->get()
            ->map(fn($r) => $this->toDomain($r))
            ->all();
    }

    public function save(Order $order): void
    {
        $record = OrderRecord::findOrNew($order->id()->value());
        $record->customer_id = $order->customerId()->value();
        $record->status = $order->status()->value();
        $record->amount = $order->amount()->toInt();
        $record->save();
    }

    private function toDomain(OrderRecord $record): Order
    {
        return new Order(
            OrderId::from($record->id),
            CustomerId::from($record->customer_id),
            OrderStatus::from($record->status),
            Money::fromInt($record->amount),
        );
    }
}
```

**ポイント:**
- `toDomain()` で Eloquent → Domain Model 変換
- `save()` で Domain Model → Eloquent 変換
- 内部で Collection を使い、戻り値は `->all()` で配列に変換

---

## 1 対 N リレーション（集約）

### Domain Model

```php
final class Order
{
    /** @param list<OrderLine> $lines */
    public function __construct(
        private OrderId $id,
        private CustomerId $customerId,
        private OrderStatus $status,
        private array $lines,
    ) {}

    public function addLine(Product $product, int $quantity): void
    {
        if ($this->status->isConfirmed()) {
            throw new DomainException('確定済み注文には追加できません');
        }

        $this->lines[] = OrderLine::create(
            orderId: $this->id,
            productId: $product->id(),
            unitPrice: $product->price(),
            quantity: $quantity,
        );
    }

    public function totalAmount(): Money
    {
        return array_reduce(
            $this->lines,
            fn(Money $sum, OrderLine $line) => $sum->add($line->subtotal()),
            Money::zero(),
        );
    }

    /** @return list<OrderLine> */
    public function lines(): array
    {
        return $this->lines;
    }
}

final class OrderLine
{
    public function __construct(
        private OrderLineId $id,
        private OrderId $orderId,
        private ProductId $productId,
        private Money $unitPrice,
        private int $quantity,
    ) {}

    public function subtotal(): Money
    {
        return $this->unitPrice->multiply($this->quantity);
    }

    // getters...
}
```

---

### Repository（集約の保存）

```php
class EloquentOrderRepository implements OrderRepository
{
    public function find(OrderId $id): Order
    {
        $record = OrderRecord::with('lines')->findOrFail($id->value());

        return $this->toDomain($record);
    }

    public function save(Order $order): void
    {
        $record = OrderRecord::findOrNew($order->id()->value());
        $record->customer_id = $order->customerId()->value();
        $record->status = $order->status()->value();
        $record->save();

        // 既存の明細を削除して再作成
        OrderLineRecord::where('order_id', $order->id()->value())->delete();

        foreach ($order->lines() as $line) {
            $lineRecord = new OrderLineRecord();
            $lineRecord->order_id = $order->id()->value();
            $lineRecord->product_id = $line->productId()->value();
            $lineRecord->unit_price = $line->unitPrice()->toInt();
            $lineRecord->quantity = $line->quantity();
            $lineRecord->save();
        }
    }

    private function toDomain(OrderRecord $record): Order
    {
        $lines = $record->lines->map(fn($r) => new OrderLine(
            OrderLineId::from($r->id),
            OrderId::from($r->order_id),
            ProductId::from($r->product_id),
            Money::fromInt($r->unit_price),
            $r->quantity,
        ))->all();

        return new Order(
            OrderId::from($record->id),
            CustomerId::from($record->customer_id),
            OrderStatus::from($record->status),
            $lines,
        );
    }
}
```

---

## UseCase

### Command（書き込み操作）

```php
final class PlaceOrderCommand
{
    public function __construct(
        public readonly int $orderId,
    ) {}
}

final class PlaceOrderHandler
{
    public function __construct(
        private OrderRepository $orderRepository,
    ) {}

    public function handle(PlaceOrderCommand $command): void
    {
        $order = $this->orderRepository->find(
            OrderId::from($command->orderId)
        );

        $order->place();

        $this->orderRepository->save($order);
    }
}
```

---

### Query（読み取り操作）

```php
final class GetOrderQuery
{
    public function __construct(
        public readonly int $orderId,
    ) {}
}

final class GetOrderHandler
{
    public function __construct(
        private OrderRepository $orderRepository,
    ) {}

    public function handle(GetOrderQuery $query): OrderDTO
    {
        $order = $this->orderRepository->find(
            OrderId::from($query->orderId)
        );

        return OrderDTO::fromDomain($order);
    }
}
```

---

## DTO

```php
final class OrderDTO
{
    public function __construct(
        public readonly int $id,
        public readonly int $customerId,
        public readonly string $status,
        public readonly int $amount,
    ) {}

    public static function fromDomain(Order $order): self
    {
        return new self(
            id: $order->id()->value(),
            customerId: $order->customerId()->value(),
            status: $order->status()->value(),
            amount: $order->amount()->toInt(),
        );
    }
}
```

---

## Controller

```php
class OrderController extends Controller
{
    public function __construct(
        private PlaceOrderHandler $placeOrderHandler,
        private GetOrderHandler $getOrderHandler,
    ) {}

    public function show(int $orderId)
    {
        $query = new GetOrderQuery($orderId);
        $order = $this->getOrderHandler->handle($query);

        return response()->json($order);
    }

    public function place(int $orderId)
    {
        $command = new PlaceOrderCommand($orderId);
        $this->placeOrderHandler->handle($command);

        return response()->json(['status' => 'ok']);
    }
}
```

---

## Query Service（読み取り専用）

表示に最適化したデータ取得。Domain Model を経由しない。

```php
interface OrderQueryService
{
    /** @return list<OrderSummary> */
    public function findRecentOrders(int $limit): array;
}

class EloquentOrderQueryService implements OrderQueryService
{
    public function findRecentOrders(int $limit): array
    {
        return OrderRecord::query()
            ->with('customer')
            ->orderByDesc('created_at')
            ->limit($limit)
            ->get()
            ->map(fn($r) => new OrderSummary(
                orderId: $r->id,
                customerName: $r->customer->name,
                status: $r->status,
                amount: $r->amount,
            ))
            ->all();
    }
}

final class OrderSummary
{
    public function __construct(
        public readonly int $orderId,
        public readonly string $customerName,
        public readonly string $status,
        public readonly int $amount,
    ) {}
}
```

**ポイント:**
- 表示用の DTO を直接生成
- Domain Model を経由しない（パフォーマンス優先）
- CQRS の Query 側

---

## Domain Event

### Event 定義

```php
final class OrderPlacedEvent
{
    public function __construct(
        public readonly OrderId $orderId,
        public readonly CustomerId $customerId,
        public readonly Money $totalAmount,
        public readonly \DateTimeImmutable $occurredAt,
    ) {}
}
```

### Domain Model でイベント記録

```php
final class Order
{
    /** @var list<object> */
    private array $domainEvents = [];

    public function place(): void
    {
        if (!$this->status->canPlace()) {
            throw new DomainException('確定できない状態です');
        }

        $this->status = OrderStatus::placed();

        $this->domainEvents[] = new OrderPlacedEvent(
            $this->id,
            $this->customerId,
            $this->totalAmount(),
            new \DateTimeImmutable(),
        );
    }

    /** @return list<object> */
    public function pullDomainEvents(): array
    {
        $events = $this->domainEvents;
        $this->domainEvents = [];
        return $events;
    }
}
```

### UseCase でイベント発行

```php
final class PlaceOrderHandler
{
    public function __construct(
        private OrderRepository $orderRepository,
        private EventDispatcher $eventDispatcher,
    ) {}

    public function handle(PlaceOrderCommand $command): void
    {
        $order = $this->orderRepository->find(
            OrderId::from($command->orderId)
        );

        $order->place();

        $this->orderRepository->save($order);

        foreach ($order->pullDomainEvents() as $event) {
            $this->eventDispatcher->dispatch($event);
        }
    }
}
```

---

## ファクトリメソッド命名規約

| 種類 | 命名 | 例 |
|------|------|-----|
| 汎用的な生成 | `from($value)` | `OrderId::from(1)` |
| 型を明示 | `fromXxx($value)` | `Money::fromInt(1000)` |
| 特殊な値 | `xxx()` | `Money::zero()` |
| 複雑な初期化 | `create(...)` | `Order::create(...)` |

---

## 次のステップ

[03_ディレクトリ構成例.md](./03_ディレクトリ構成例.md) に進む
