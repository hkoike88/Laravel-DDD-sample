# アーキテクチャ設計

## 目的

Domain Model と Eloquent Model を分離し、**「変わりにくい業務の核」を安定して守る**。

---

## 分離するメリット

| メリット | 説明 |
|----------|------|
| **Unit テストが軽く・安定** | DB や Facade を使わない純粋なテストが可能 |
| **リファクタ耐性が高い** | テーブル構造変更が Domain に波及しにくい |
| **仕様が読みやすい** | 判断・制約・状態遷移が Domain に集約 |
| **将来の拡張に強い** | キャッシュ導入、DB 変更、外部 API 併用 |

---

## 論理アーキテクチャ

```
┌─────────────────────────────────────────────────────┐
│                  Presentation                        │
│              (Controller / CLI / API)                │
└─────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────┐
│                    Application                       │
│                  (UseCase / DTO)                     │
└─────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────┐
│                      Domain                          │
│          (Entity / ValueObject / Service)            │
└─────────────────────────────────────────────────────┘
                          ↑
┌─────────────────────────────────────────────────────┐
│                   Infrastructure                     │
│              (Eloquent / API / Cache)                │
└─────────────────────────────────────────────────────┘
```

---

## 各レイヤーの責務

### Presentation 層

**責務:** 外部からの入力を受け取り、出力を返す

| コンポーネント | 責務 |
|---------------|------|
| Controller | HTTP リクエスト/レスポンス処理 |
| FormRequest | 入力バリデーション |
| Resource | API レスポンス整形 |
| CLI Command | コンソールコマンド |

**禁止事項:**
- ビジネスロジックを書かない
- DB を直接操作しない

---

### Application 層

**責務:** ユースケース（業務フロー）の実装

| コンポーネント | 責務 |
|---------------|------|
| UseCase | 業務フローの調整 |
| Command / Query | ユースケースの入力 |
| DTO | レイヤー間のデータ転送 |
| Handler | コマンド/クエリの処理 |

**禁止事項:**
- ビジネスルールを書かない（Domain に委譲）
- Eloquent を直接操作しない

---

### Domain 層

**責務:** ビジネスロジックの核心

| コンポーネント | 責務 |
|---------------|------|
| Entity | ID で識別されるオブジェクト |
| ValueObject | 値で識別される不変オブジェクト |
| Domain Service | エンティティに属さないビジネスロジック |
| Repository Interface | 永続化の抽象（インターフェース） |
| Domain Event | ドメインで起きた出来事 |

**禁止事項:**
- Laravel を知らない
- DB を知らない
- 外部サービスを知らない

---

### Infrastructure 層

**責務:** 外部サービス・フレームワークとの連携

| コンポーネント | 責務 |
|---------------|------|
| Eloquent Model | DB テーブルのマッピング |
| Repository 実装 | Repository Interface の具体実装 |
| API Client | 外部 API との連携 |
| Cache | キャッシュ実装 |

---

## 依存関係のルール

```
[Presentation] → [Application] → [Domain] ← [Infrastructure]
```

### 依存の向き

| レイヤー | 依存先 |
|----------|--------|
| Presentation | Application |
| Application | Domain |
| Infrastructure | Domain（インターフェース実装） |
| **Domain** | **何にも依存しない** |

### 依存逆転の原則（DIP）

```php
// Domain 層: インターフェースを定義
interface OrderRepository
{
    public function find(OrderId $id): Order;
    public function save(Order $order): void;
}

// Infrastructure 層: インターフェースを実装
class EloquentOrderRepository implements OrderRepository
{
    public function find(OrderId $id): Order { /* Eloquent で実装 */ }
    public function save(Order $order): void { /* Eloquent で実装 */ }
}
```

---

## 集約（Aggregate）の設計

### 集約とは

- **トランザクション整合性の境界**
- 集約ルート経由でのみ内部を操作
- 1 つの集約は 1 つのトランザクションで保存

### 境界の決め方

| 判断基準 | 結果 |
|----------|------|
| 一緒に変更されるか？ | → 同じ集約 |
| 独立して存在できるか？ | → 別の集約 |
| トランザクション整合性が必要か？ | → 同じ集約 |

### 例: EC サイト

```
[Order 集約]
├── Order (集約ルート)
└── OrderLine (子エンティティ)

[Customer 集約]
└── Customer (集約ルート)

[Product 集約]
└── Product (集約ルート)
```

- `Order` と `OrderLine` は一緒に変更される → 同じ集約
- `Order` と `Customer` は独立して存在 → 別の集約

### 集約間の参照

```php
// ✗ Bad: 直接オブジェクト参照
final class Order
{
    public function __construct(
        private OrderId $id,
        private Customer $customer,  // NG: 他の集約を直接参照
    ) {}
}

// ✓ Good: ID で参照
final class Order
{
    public function __construct(
        private OrderId $id,
        private CustomerId $customerId,  // OK: ID のみ保持
    ) {}
}
```

---

## トランザクション管理

### 基本方針

- Repository 単体ではトランザクションを開始しない
- UseCase で業務トランザクションの範囲を制御

### パターン 1: UseCase で DB::transaction()

```php
final class PlaceOrderUseCase
{
    public function execute(PlaceOrderCommand $command): PlaceOrderResult
    {
        return DB::transaction(function () use ($command) {
            $order = Order::create(...);
            $this->orderRepository->save($order);

            $payment = Payment::createFor($order);
            $this->paymentRepository->save($payment);

            return new PlaceOrderResult($order->id()->value());
        });
    }
}
```

### パターン 2: TransactionManager を注入

```php
interface TransactionManager
{
    public function transaction(callable $callback): mixed;
}

final class PlaceOrderUseCase
{
    public function __construct(
        private OrderRepository $orderRepository,
        private TransactionManager $transaction,
    ) {}

    public function execute(PlaceOrderCommand $command): PlaceOrderResult
    {
        return $this->transaction->transaction(function () use ($command) {
            // ...
        });
    }
}
```

---

## 例外設計

### ドメイン例外とインフラ例外を分離

```php
// Domain 層の例外（業務ルール違反）
namespace Domain\Exception;

class DomainException extends \DomainException {}
class OrderAlreadyConfirmedException extends DomainException {}
class InsufficientStockException extends DomainException {}

// Infrastructure 層の例外（技術的問題）
namespace Infrastructure\Exception;

class InfrastructureException extends \RuntimeException {}
class OrderNotFoundException extends InfrastructureException {}
```

### Controller での例外ハンドリング

```php
public function confirm(string $orderId)
{
    try {
        $this->confirmOrderUseCase->execute(OrderId::from($orderId));
        return response()->json(['status' => 'ok']);
    } catch (OrderAlreadyConfirmedException $e) {
        return response()->json(['error' => '既に確定済みです'], 400);
    } catch (OrderNotFoundException $e) {
        return response()->json(['error' => '注文が見つかりません'], 404);
    }
}
```

---

## アンチパターン

| アンチパターン | 問題点 |
|---------------|--------|
| Domain が Eloquent を継承 | DB に依存、テスト困難 |
| Domain から Facade を呼ぶ | フレームワークに依存 |
| Repository が薄いラッパーだけ | ドメインへの翻訳責務を果たしていない |
| Controller にビジネスロジック | Fat Controller、テスト困難 |
| UseCase が複数の責務を持つ | 単一責任の原則違反 |

---

## チェックリスト

- [ ] Domain が Laravel / DB を知らない
- [ ] ビジネス判断が Eloquent に入っていない
- [ ] Unit テストが DB なしで書ける
- [ ] DB 都合の変更が Domain に影響しにくい
- [ ] 集約の境界が明確
- [ ] Repository がドメイン変換を担当している

---

## 次のステップ

[02_実装パターン.md](./02_実装パターン.md) に進む
