# PHPMetrics 指標説明ガイド

## 目次

- [1. 概要](#1-概要)
- [2. Overview（概要）ページ](#2-overview概要ページ)
- [3. Violations（違反）ページ](#3-violations違反ページ)
- [4. Size & Volume（サイズとボリューム）ページ](#4-size--volumeサイズとボリュームページ)
- [5. Complexity & Defects（複雑度と欠陥）ページ](#5-complexity--defects複雑度と欠陥ページ)
- [6. Object Oriented Metrics（オブジェクト指向メトリクス）ページ](#6-object-oriented-metricsオブジェクト指向メトリクスページ)
- [7. Coupling（結合度）ページ](#7-coupling結合度ページ)
- [8. まとめ：指標の活用方法](#8-まとめ指標の活用方法)

---

## 1. 概要

PHPMetrics は PHP コードの品質を測定・可視化するための静的解析ツールです。
このドキュメントでは、PHPMetrics が提供する各指標の意味と、それらをどのように解釈すべきかを説明します。

### レポート閲覧方法

```bash
# PHPMetrics 実行（Makefile経由）
make phpmetrics

# レポート閲覧
# ブラウザで http://localhost:8888 を開く
```

---

## 2. Overview（概要）ページ

プロジェクト全体の健全性を一目で把握できるダッシュボードです。

### 2.1 Violations（違反）

**意味:** コード品質のルール違反数

**表示項目:**
- **Total**: 違反総数
- **Criticals**: 重大な違反（即座に修正すべき）
- **Errors**: エラーレベルの違反（優先的に修正すべき）
- **Warnings**: 警告レベルの違反（改善が望ましい）
- **Information**: 情報レベル（参考情報）

**目標値:**
- Criticals: **0**
- Errors: **0**
- Warnings: できるだけ少なく（プロジェクト規模による）

**対応優先度:**
1. Criticals（最優先）
2. Errors（高）
3. Warnings（中）
4. Information（低）

---

### 2.2 Lines of Code（コード行数）

**意味:** プロジェクト全体のコード行数

**解釈:**
- プロジェクトの規模を示す基本的な指標
- 単独では品質を表さないが、他の指標と組み合わせて判断
- 1クラスあたりの平均行数を確認し、適切なサイズを維持

---

### 2.3 Classes（クラス数）

**意味:** プロジェクト内のクラス総数

**解釈:**
- プロジェクトの規模とアーキテクチャスタイルを反映
- DDD アーキテクチャでは、ValueObject、Entity、Repository 等が多数存在するため、クラス数は多くなる傾向がある
- 総コード行数をクラス数で割ることで、1クラスあたりの平均行数を算出できる
- 一般的に1クラスあたり50-100行程度が適切

---

### 2.4 Average Cyclomatic Complexity by Class（クラスあたりの平均循環的複雑度）

**意味:** クラスの複雑さを示す指標。分岐（if, for, while等）が多いほど値が大きくなる。

**目標値:**
- **1-10**: シンプルで理解しやすい ✅
- **11-20**: やや複雑、リファクタリング検討
- **21-50**: 複雑、リファクタリング推奨
- **51以上**: 非常に複雑、即座にリファクタリング必要

**解釈:**
- 値が低いほど、コードがシンプルで理解しやすい
- プロジェクト全体で5以下を目指すと良好

---

### 2.5 Average Bugs by Class（クラスあたりの平均バグ数）

**意味:** Halstead メトリクスに基づく予測バグ数

**目標値:**
- **0-0.1**: 非常に良好 ✅
- **0.1-0.5**: 良好
- **0.5以上**: 改善が必要

**解釈:**
- 統計的手法によりバグの可能性を予測
- 値が低いほどコードの品質が高い

---

### 2.6 ClassRank（クラスランク）

**意味:** Google の PageRank をクラス間の依存関係に適用した指標。他のクラスから多く参照されるクラスほど高い値になる。

**解釈:**
- 高い値を持つクラス = プロジェクトの中核となるクラス
- これらのクラスを変更すると影響範囲が大きいため、慎重に扱う必要がある

**活用方法:**
- 高 ClassRank のクラスは特に注意深くテストを書く
- リファクタリング時は影響範囲を慎重に確認
- ドメイン層の中核的なクラス（Entity、ValueObject等）が高い値を示すことが多い

---

## 3. Violations（違反）ページ

コード品質のルール違反を詳細に表示します。

### 3.1 Class Violations（クラス違反）

#### 3.1.1 Blob / God Object（ブロブ/ゴッドオブジェクト）

**意味:** 責務が多すぎる肥大化したクラス

**問題点:**
- 単一責任の原則に違反
- 理解が困難
- テストが困難
- 変更の影響範囲が大きい

**検出基準:**
- クラスサイズが大きい
- 多数のメソッドを持つ
- LCOM（凝集度）が低い

**対策:**
- クラスを責務ごとに分割
- 関連するメソッドをグループ化して別クラスに抽出
- 単一責任の原則を適用

---

#### 3.1.2 Probably Bugged（バグの可能性）

**意味:** 複雑度が高く、バグが含まれている可能性が高いクラス

**検出基準:**
- 循環的複雑度が高い
- 予測バグ数が多い

**対策:**
- ユニットテストのカバレッジを上げる
- コードレビューを強化
- 複雑なロジックをシンプルに書き直す
- メソッドを小さく分割

---

### 3.2 Package Violations（パッケージ違反）

#### 3.2.1 Stable Abstractions Principle（安定抽象化の原則）違反

**意味:** 安定したパッケージ（多くのパッケージから依存される）は、抽象度が高くあるべき

**問題点:**
- 安定したパッケージに具象クラスが多い
- 変更の影響範囲が大きくなる
- 拡張性が低下

**対策:**
- インターフェースを導入
- 具象実装を別パッケージに移動
- 抽象度を高める設計に変更

---

#### 3.2.2 Stable Dependencies Principle（安定依存の原則）違反

**意味:** 不安定なパッケージは、より安定したパッケージに依存すべき

**問題点:**
- 安定したパッケージが不安定なパッケージに依存している
- 循環依存のリスク
- 変更が連鎖的に波及

**対策:**
- 依存関係を見直し、安定したパッケージへの依存に変更
- 依存関係逆転の原則（DIP）を適用
- レイヤードアーキテクチャを見直す

---

## 4. Size & Volume（サイズとボリューム）ページ

コードのサイズとボリュームに関する指標を表示します。

### 4.1 LLOC（Logical Lines of Code）

**意味:** 論理的なコード行数（空行やコメントを除く実行可能な行数）

**解釈:**
- クラスの実際のサイズを示す
- 一般的に、1クラスあたり100-200行以下が望ましい

**目安:**
- **0-50**: 小さいクラス ✅
- **51-100**: 適度なサイズ ✅
- **101-200**: やや大きい
- **201以上**: 大きすぎる、分割を検討

---

### 4.2 CLOC（Comment Lines of Code）

**意味:** コメント行数

**解釈:**
- コメントの量を示す
- ドキュメンテーションの充実度を測る指標
- Comment Weight と組み合わせて評価

---

### 4.3 Volume（ボリューム）

**意味:** Halstead メトリクスに基づくコードの情報量

**解釈:**
- コードの理論的な長さを示す
- 値が大きいほど、理解に時間がかかる

**目安:**
- 低いほど理解しやすい
- 高い場合は、コードの分割を検討

---

### 4.4 Intelligent Content（インテリジェントコンテンツ）

**意味:** コードの本質的な複雑さを示す指標

**解釈:**
- 単純な反復コードは値が低く、複雑なロジックは値が高い
- 値が高い場合は、コードレビューとテストを強化

---

### 4.5 Comment Weight（コメント重み）

**意味:** コメントの割合を示す指標

**計算式:** `Comment Weight = CLOC / (LLOC + CLOC) * 100`

**目安:**
- **30-50%**: 適切なコメント量 ✅
- **0-20%**: コメント不足
- **60%以上**: コメント過多（コードをシンプルにすべき）

**解釈:**
- 適度なコメントは理解を助ける
- 過度なコメントはコードの複雑さを示す可能性

---

## 5. Complexity & Defects（複雑度と欠陥）ページ

コードの複雑度と予測される欠陥数を表示します。

### 5.1 WMC（Weighted Method Count）

**意味:** クラス内の全メソッドの循環的複雑度の合計

**解釈:**
- クラス全体の複雑さを示す
- 値が大きいほど、クラスが複雑

**目安:**
- **0-10**: シンプル ✅
- **11-20**: やや複雑
- **21以上**: 複雑、リファクタリング推奨

---

### 5.2 Class Cyclomatic Complexity（クラス循環的複雑度）

**意味:** クラス全体の循環的複雑度（分岐数に基づく）

**解釈:**
- 分岐が多いほど値が大きくなる
- テストケース数の目安になる
- 必要なテストケース数 ≒ 循環的複雑度 + 1

**目安:**
- **1-10**: シンプル ✅
- **11-20**: やや複雑
- **21以上**: 複雑

---

### 5.3 Max Method Cyclomatic Complexity（最大メソッド循環的複雑度）

**意味:** クラス内で最も複雑なメソッドの循環的複雑度

**解釈:**
- 最も複雑なメソッドの複雑さを示す
- 高い値のメソッドは、リファクタリング対象

**目安:**
- **1-5**: シンプル ✅
- **6-10**: やや複雑
- **11以上**: 複雑、リファクタリング推奨

---

### 5.4 Relative System Complexity（相対システム複雑度）

**意味:** システム全体における相対的な複雑度

**解釈:**
- 他のクラスと比較した複雑さを示す
- 高い値のクラスは、プロジェクト内で特に複雑
- 重点的なレビューとテストの対象

---

### 5.5 Relative Data Complexity（相対データ複雑度）

**意味:** データ構造の複雑さ

**解釈:**
- データの扱いが複雑なクラスは値が高い
- 高い場合は、データ構造の見直しを検討

---

### 5.6 Relative Structural Complexity（相対構造複雑度）

**意味:** クラス構造の複雑さ

**解釈:**
- メソッド間の関係が複雑なクラスは値が高い
- 高い場合は、クラスの分割を検討

---

### 5.7 Bugs（Halstead メトリクスによるバグ数）

**意味:** Halstead メトリクスに基づく予測バグ数

**計算式:** `Bugs = Volume / 3000`

**解釈:**
- コードのボリュームから統計的にバグ数を予測
- 値が高いクラスは、テストを強化

**目安:**
- **0-0.1**: 良好 ✅
- **0.1-0.5**: 注意
- **0.5以上**: 要改善

---

### 5.8 Defects（Kan メトリクスによる欠陥数）

**意味:** Kan メトリクスに基づく予測欠陥数

**解釈:**
- コードの複雑さから欠陥数を予測
- 値が高いクラスは、コードレビューを強化

**目安:**
- **0-0.5**: 良好 ✅
- **0.5-1.0**: 注意
- **1.0以上**: 要改善

---

## 6. Object Oriented Metrics（オブジェクト指向メトリクス）ページ

オブジェクト指向設計の品質を測定する指標を表示します。

### 6.1 LCOM（Lack of Cohesion of Methods）

**意味:** メソッドの凝集度の欠如を示す指標

**解釈:**
- 値が高いほど、クラス内のメソッド間の関連性が低い
- 値が高い場合は、クラスの責務が複数ある可能性

**目安:**
- **0-2**: 高凝集（良好）✅
- **3-5**: やや低凝集
- **6以上**: 低凝集、クラスの分割を検討

**対策:**
- 関連性の低いメソッドを別クラスに分離
- 単一責任の原則に従ってクラスを分割
- メソッドが共通のフィールドを使用するように設計

---

### 6.2 Volume（ボリューム）

**意味:** Halstead メトリクスに基づくコードの情報量

**解釈:**
- コードの理論的な長さを示す
- Size & Volume ページと同じ指標

---

### 6.3 Bugs（バグ数）

**意味:** Halstead メトリクスに基づく予測バグ数

**解釈:**
- Complexity & Defects ページと同じ指標

---

### 6.4 Difficulty（難易度）

**意味:** Halstead メトリクスに基づくコードの理解の難しさ

**解釈:**
- 値が高いほど、コードの理解が困難
- 高い場合は、コードのシンプル化を検討

**目安:**
- **0-10**: 理解しやすい ✅
- **10-20**: やや難しい
- **20以上**: 難しい

**対策:**
- コードのシンプル化
- 適切なコメントの追加
- メソッドの分割

---

## 7. Coupling（結合度）ページ

クラス間の結合度を測定する指標を表示します。

### 7.1 Afferent Coupling（AC / 求心的結合度）

**意味:** そのクラスを参照している他のクラスの数

**解釈:**
- 値が高いほど、多くのクラスから依存されている
- 値が高いクラスを変更すると、影響範囲が大きい

**注意点:**
- 高 AC のクラスは、変更時に影響範囲が大きいため慎重に扱う
- インターフェースを導入して依存を抽象化することを検討
- ドメイン層の中核クラスは自然と高くなる（正常な状態）

---

### 7.2 Efferent Coupling（EC / 遠心的結合度）

**意味:** そのクラスが依存している他のクラスの数

**解釈:**
- 値が高いほど、多くのクラスに依存している
- 値が高いクラスは、依存するクラスの変更に影響を受けやすい

**注意点:**
- 高 EC のクラスは、依存するクラスの変更に影響を受けやすい
- 依存関係の見直しや、依存性注入（DI）の活用を検討
- Application層やPresentation層は自然と高くなる傾向

---

### 7.3 Instability（不安定性）

**意味:** クラスの変更のしやすさを示す指標

**計算式:** `Instability = EC / (AC + EC)`

**解釈:**
- **0**: 完全に安定（多くのクラスから依存されているが、他のクラスに依存していない）
- **1**: 完全に不安定（他のクラスに依存しているが、どのクラスからも依存されていない）

**目安:**
- **0-0.3**: 安定（変更しにくい）
- **0.4-0.6**: 中程度
- **0.7-1.0**: 不安定（変更しやすい）

**活用方法:**
- **ドメイン層**: 安定している方が良い（低い値が望ましい）
  - Entity、ValueObject、DomainService等
  - 変更が少なく、多くのクラスから依存される
- **Application層/Presentation層**: 不安定で良い（高い値が許容される）
  - UseCase、Controller等
  - ビジネス要件に応じて柔軟に変更

**理想的な構造:**
```
Domain層（安定）← Application層（中程度）← Presentation層（不安定）
   ↑                                              ↑
Instability: 0-0.3                    Instability: 0.7-1.0
```

---

### 7.4 ClassRank

**意味:** Overview ページと同じ指標（Google の PageRank を適用）

**補足:**
- Coupling ページでは、各クラスの ClassRank を確認できる
- 高い値のクラスを特定し、重点的に品質管理

---

## 8. まとめ：指標の活用方法

### 8.1 優先的に対応すべき項目

#### 🔴 最優先（すぐに対応）

1. **Violations の Criticals と Errors**
   - 目標: Criticals 0件、Errors 0件
   - 即座に修正が必要

2. **Blob / God Object 違反**
   - クラスを責務ごとに分割
   - 単一責任の原則を適用

3. **Probably Bugged 違反**
   - テストカバレッジを上げる
   - コードをシンプル化

---

#### 🟡 中優先（計画的に対応）

1. **高 LCOM クラス（6以上）**
   - クラスの分割を検討
   - 単一責任の原則を適用

2. **高 WMC / 高複雑度クラス（WMC > 20）**
   - 複雑なメソッドをリファクタリング
   - メソッドの分割

3. **高 Difficulty クラス（> 20）**
   - コードのシンプル化
   - コメントの追加
   - ドキュメントの充実

---

#### 🟢 低優先（長期的に改善）

1. **Warnings の削減**
   - 継続的に削減
   - 新規 Warnings を追加しない

2. **Package Violations の解消**
   - Stable Abstractions Principle 違反
   - Stable Dependencies Principle 違反
   - アーキテクチャの見直し、インターフェースの導入

---

### 8.2 定期的な確認

#### 毎回のコミット前
- Violations の Criticals と Errors が増えていないか確認

#### スプリント終了時
- Violations の総数が減っているか確認
- 平均複雑度が増えていないか確認

#### リリース前
- 全ての Criticals と Errors が解消されているか確認
- 高リスククラス（高複雑度、高結合度）のテストカバレッジが十分か確認

---

### 8.3 良好な指標を維持するために

#### コーディング時の心がけ

1. **単一責任の原則を守る**
   - 1クラス1責務を意識
   - LCOM を低く保つ

2. **複雑度を抑える**
   - メソッドは短く（20行以内が目安）
   - 深いネストを避ける（3階層以内が目安）
   - 早期リターンを活用

3. **結合度を低く保つ**
   - 依存性注入（DI）を活用
   - インターフェースを使って抽象に依存

4. **適切なコメントを書く**
   - なぜそのコードを書いたのか（Why）を説明
   - 複雑なロジックには必ずコメントを付ける

---

#### コードレビュー時の確認事項

1. **新規クラスの指標を確認**
   - LCOM が高くないか
   - 循環的複雑度が高くないか

2. **既存クラスの変更で指標が悪化していないか**
   - 複雑度が上がっていないか
   - 結合度が上がっていないか

3. **テストカバレッジの確認**
   - 複雑なクラスは特に高いカバレッジを目指す

---

### 8.4 参考: 理想的な目標値

| 指標 | 理想値 |
|------|--------|
| Violations (Criticals) | 0 |
| Violations (Errors) | 0 |
| Violations (Warnings) | プロジェクト規模により異なる（できるだけ少なく） |
| Average Cyclomatic Complexity | < 5 |
| Average Bugs by Class | < 0.1 |
| Average LCOM | < 3 |
| Comment Weight | 30-50% |
| クラスサイズ（LLOC） | < 100行 |
| メソッド循環的複雑度 | < 10 |

---

## 参考資料

### PHPMetrics 公式ドキュメント
- https://phpmetrics.github.io/website/

### 関連する設計原則
- **SOLID 原則**
  - 単一責任の原則（SRP）
  - 開放閉鎖の原則（OCP）
  - リスコフの置換原則（LSP）
  - インターフェース分離の原則（ISP）
  - 依存性逆転の原則（DIP）

- **パッケージ設計原則**
  - 安定抽象化の原則（SAP）
  - 安定依存の原則（SDP）

### メトリクス関連
- **Halstead メトリクス**: コードの複雑さと予測バグ数を計算
- **循環的複雑度（Cyclomatic Complexity）**: テストケース数の目安
- **LCOM（Lack of Cohesion of Methods）**: クラスの凝集度を測定

---

## 更新履歴

| 日付 | 内容 |
|------|------|
| 2026-01-11 | 初版作成 |
